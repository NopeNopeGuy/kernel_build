#! /bin/sh
# SPDX-License-Identifier: GPL-2.0
#
# (c) 2020, Google
LANG=C
progname="${0##*/}"

GIT=${GIT:-git}

# A _real_ embedded tab character
TAB="`echo | tr '\n' '\t'`"
SPACE="[ ${TAB}]"
SPACES="${SPACE}\{1,\}"
# A _real_ embedded escape character
ESCAPE="`echo | tr '\n' '\033'`"
# Colours
GREEN="${ESCAPE}[38;5;40m"
RED="${ESCAPE}[38;5;196m"
ORANGE="${ESCAPE}[38;5;255:165:0m"
BLUE="${ESCAPE}[35m"
NORMAL="${ESCAPE}[0m"

USAGE="${RED}USAGE${NORMAL}: ${progname} [-k kernelgitdir]... [-s sha]... \\
          [-b bug]... [-r oldname newname]... [< patchfile]

Outputs are in <kernelgitdir>/split.patch, existing files are overwritten

Helpful when taking cherry picks to determine which portions contribute
to ABI (upstream) and which ones do not (device only).  Not the be all
and end all but should help managing the focus on what goes into the
kernel.org or android-common kernel, and which should stay where they
belong in the driver or device specific code in the kernel.

Take the list of shas and split them up based on which kernel their
contribution should be made to.  The list of kernels should start
with the lowest branch, which would be the most likely to contain
the change, to the highest, being the most upstream tree that needs
to be inspected.  The split will check the upstream first for the
overlapping content, down to the lowest.  The patches may also be
split up into partials that overlap the available files in the tree.

-b bug             * add a bug number to the new commit footer
-k kernelgitdir    * Directory where the kernel is found.  There must be
                     more than two directories specified for this patch to
                     be of any use, even if the intent is that the commits
                     come from one tree, and are cherry-picked to another.
-r onename newname * rename files specified in the patch before they are
                     evaluated.  This helps when a file needlesly overlaps
                     upstream content.
-s sha             * change sha to evaluate. If non specified, then the
                     git am format-patch -n -k content supplied to stdin."

kernels=
shas=
bugs=
renames=
debug=false
while [ ${#} -gt 0 ]; do
  case ${1} in
    -b=* | --bug=*)
      b=${1#-b=}
      b=${b#--bug=}
      [ -z "${bugs}" ] || bugs="${bugs} "
      bugs="${bugs}${b}"
      ;;
    -b | --bug)
      shift
      [ -z "${bugs}" ] || bugs="${bugs} "
      bugs="${bugs}${1}"
      ;;
    -d | --debug | -v | --verbose)
      debug=true
      ;;
    -h | -\? | --help)
      echo "${USAGE}" >&2
      exit
      ;;
    -K=* | -k=* | --kernel=* | --git=*) # -K is only for hardening against humans
      k=${1#-k=}
      k=${k#--kernel=}
      k=${k#--git=}
      k=${k#-K=}
      [ -z "${kernels}" ] || kernels="${kernels} "
      kernels="${kernels}${k}"
      ;;
    -K | -k | --kernel | --git) # -S is only for hardening against humans
      shift
      [ -z "${kernels}" ] || kernels="${kernels} "
      kernels="${kernels}${1}"
      ;;
    -r=*[,:]* | --rename=*[,:]*)
      l=${1#-r=}
      l=${l#--rename=}
      r=${l##*[,:]}
      l=${l%[,:]${r}}
      [ -z "${renames}" ] || renames="${renames} "
      renames="${renames}${l}:${r}"
      ;;
    -r | --rename)
      shift
      r=${1##*[,:]}
      if [ X"${1}" != X"${r}" ]; then
        l=${1%[,:]${r}}
      else
        shift
        l=${r}
        r=${1}
      fi
      [ -z "${renames}" ] || renames="${renames} "
      renames="${renames}${l}:${r}"
      ;;
    -S=* | -s=* | --sha=*) # -S is only for hardening against humans
      s=${1#-s=}
      s=${s#-S=}
      s=${s#--sha=}
      if [ "${s}" != "${s#\#}" ]; then
        break
      fi
      [ -z "${shas}" ] || shas="${shas} "
      shas="${shas}${s}"
      ;;
    -S | -s | --sha) # -S is only for hardening against humans
      shift
      if [ "${1}" != "${1#\#}" ]; then
        break
      fi
      [ -z "${shas}" ] || shas="${shas} "
      shas="${shas}${1}"
      ;;
    *)
      echo "${RED}[    ERROR ]${NORMAL} Unexpected Argument(s): ${*}" >&2
      echo >&2
      echo "${USAGE}" >&2
      exit 1
      ;;
  esac
  shift
done

[ "USAGE: string_to_regex [string | < stdin]

Convert a string to a direct match regex (or blob)" ]
string_to_regex() {
  if [ -z "${*}" ]; then
    sed 's/[].*+[]/[&]/g'
  else
    echo "${@}" |
      sed 's/[].*+?[]/[&]/g'
  fi
}

[ "USAGE: unique

Filter to drop any duplicate entries, preserve order" ]
unique() {
  list=
  while read line; do
    if [ -z "${list}" ]; then
      list="${line}"
      echo "${line}"
    elif ! echo "${list}" |
             grep "^`string_to_regex \"${line}\"`" >/dev/null; then
      list="${list}
${line}"
      echo "${line}"
    fi
  done
  list=
}

[ "USAGE: space_to_newline_unique

Filter to convert spaces to newline, then remove duplicate entries" ]
space_to_newline_unique() {
  tr " ${TAB}" '\n\n' |
    unique |
    grep --invert-match '^$'
}

[ "USAGE: newline_to_space_unique

Filter to remove duplicate, then convert newline to space" ]
newline_to_space_unique() {
  unique |
    tr '\n' ' ' |
    sed "s/${SPACES}/ /
         s/ \$//"
  echo
}

shas="`echo ${shas} |
         space_to_newline_unique |
         sed --expression \"s/${SPACES}\#.*//\" \
             --expression \"/^${SPACES}\$/d\"`"
nshas=`echo ${shas} |
         wc --words`

if ${debug}; then
  n=`echo ${bugs} | wc --words`
  echo "${BLUE}[     INFO ]${NORMAL} bugs[${n}]={${bugs}}" >&2
  n=`echo ${kernels} | wc --words`
  echo "${BLUE}[     INFO ]${NORMAL} kernels[${n}]={${kernels}}" >&2
  echo "${BLUE}[     INFO ]${NORMAL} shas[${nshas}]={"${shas}"}" >&2
  n=`echo ${renames} | wc --words`
  echo "${BLUE}[     INFO ]${NORMAL} renames[${n}]={${renames}}" >&2
fi

if [ `echo ${kernels} | wc --words` -lt 2 ]; then
  echo "${RED}[    ERROR ]${NORMAL} Too few kernels, must be 2 or more: ${kernels}" >&2
  echo >&2
  echo "${USAGE}" >&2
  exit 1
fi

short_shas="`echo \"${shas}\" | grep '^[0-9a-fA-F]\{6,16\}$'`"
dup_shas=
if [ -n "${short_shas}" ]; then
  short_shas_regex="`echo \"${short_shas}\" | sed 's/.*/^&[0-9a-fA-F]/'`"
  dup_shas="`echo \"${shas}\" | grep \"${short_shas_regex}\"`"
  if [ -n "${dup_shas}" ]; then
    dup_shas="`echo \"${dup_shas}\" |
                 sed 's/^\([0-9a-fA-F]\{6,16\}\).*/\1.../'`"
    echo "${ORANGE}[  WARNING ]${NORMAL} duplicate shas" ${dup_shas} >&2
  fi
fi

AUTHOR_NAME="`git config user.name 2>/dev/null`"
AUTHOR_EMAIL="`git config user.email 2>/dev/null`"
for k in ${kernels}; do
  if [ -z "${AUTHOR_NAME}" ]; then
    AUTHOR_NAME="`cd ${k} && git config user.name 2>/dev/null`"
    AUTHOR_EMAIL="`cd ${k} && git config user.email 2>/dev/null`"
  fi
  if [ ! -d ${k} ]; then
    echo "${RED}[    ERROR ]${NORMAL} Kernel directory ${k} does not exist!" >&2
    exit 1
  fi
  if [ ! -d ${k}/.git ]; then
    echo "${RED}[    ERROR ]${NORMAL} Kernel directory ${k} is not a git repostory!" >&2
    exit 1
  fi
done

RENAME_SED_SCRIPT=
for r in ${renames}; do
  oldname="${r%:*}"
  newname="${r#${oldname}:}"
  if [ -z "${oldname}" -o -z "${newname}" ]; then
    echo "${RED}[    ERROR ]${NORMAL} rename format \"${oldname}\":\"${newname}\"!" >&2
    exit 1
  fi
  if [ "${oldname}" != "${oldname%@*}" ]; then
    echo "${RED}[    ERROR ]${NORMAL} rename format \"${oldname}\" contains @!" >&2
    exit 1
  fi
  if [ "${newname}" != "${newname%@*}" ]; then
    echo "${RED}[    ERROR ]${NORMAL} rename format \"${newname}\" contains @!" >&2
    exit 1
  fi
  oldname="`string_to_regex \"${oldname}\"`"
  [ -z "${RENAME_SED_SCRIPT}" ] || RENAME_SED_SCRIPT="${RENAME_SED_SCRIPT}
"
  RENAME_SED_SCRIPT="${RENAME_SED_SCRIPT}s@^${oldname}\$@${newname}@
    s@^\(---${SPACES}a/\|[+][+][+]${SPACES}b/\|diff${SPACE}.*${SPACES}b/\)${oldname}\$@\1${newname}@
    s@^\(diff.*${SPACE}a/\)${oldname}${SPACES}@\1${newname} @"
done

#
# oneline format:
#   originalsha actualfullsha title
# shas format
#   originalsha
#   originalsha actualfullsha
# titles format
#   originalsha title
#

[ "USAGE: twin_shas < longshas

input can be one of:
sha sha
sha longsha
longsha

output will always be:
sha longsha

\${shas}   - newline separated list of commits to sort" ]
twin_shas() {
  sed --expression "`echo \"${shas}\" |
                       sed --quiet \
                           --expression \"s@^\([0-9a-fA-F]\{6,\}\)${SPACES}\([0-9a-fA-F]\{32,\}\)\\\$@s/^\2\$/\1 \2/@p\" \
                           --expression \"s@^\([0-9a-fA-F]\{6,32\}\)${SPACES}\1\\\$@s/^\1\\\\\\([0-9a-fA-F]\\\\\\{8,\\\\\\}\\\\\\)\$/\1 \1\\\\\\1/@p\"`" \
      --expression 's/^\([0-9a-fA-F]\{16,16\}\)\([0-9a-fA-F]\{20,\}\)$/\1 \1\2/'
}

[ "USAGE: sort_shas

\${shas}    - newline separated list of commits to sort
\${index}   - index where sorted shas and oneline output is located
\${kernels} - list of kernels to pick up shas from (or none if empty)
\${TMP}     - temporary directory
\${GIT}     - git tool path
\${RED}     - colour red
\${NORMAL}  - and back again" ]
sort_shas() {
  if [ -z "${shas}" ]; then
    return
  fi
  ret=0
  shas="`echo \"${shas}\" |
           unique`"
  nshas=`echo "${shas}" |
           wc --lines` &&
  if [ ${nshas} -gt 0 ]; then
    second_shas="`echo \"${shas}\" |
                    sed \"s/^[0-9a-fA-F]*${SPACES}//\"`"
    my_shas="`echo ${shas} |
                space_to_newline_unique |
                sed 's/^/^/'`"
    (
      ${GIT} rev-list --topo-order --reverse --missing=allow-any ${second_shas} --
      if [ -n "${kernels}" ]; then
        cat ${TMP}[0-9]/shas ${TMP}[0-9][0-9]/shas 2>/dev/null
      fi
    ) |
      grep "${my_shas}" |
      unique |
      grep "${my_shas}" --max-count=${nshas} |
      twin_shas |
      tee ${TMP}${index}/shas |
      while read sha fullsha; do
        if [ -z ${fullsha} ]; then
          fullsha=${sha}
        fi
        ${GIT} log --pretty=full --pretty=oneline --max-count=1 ${fullsha} |
          sed "s/^/${sha} /"
      done >${TMP}${index}/oneline ||
        ret=${?}
    actual_nshas=`wc --lines < ${TMP}${index}/shas`
    [ -s ${TMP}${index}/shas ] || rm ${TMP}${index}/shas
    [ -s ${TMP}${index}/oneline ] || rm ${TMP}${index}/oneline
    if [ "${actual_nshas}" != ${nshas} ]; then
      echo "${RED}[    ERROR ]${NORMAL} Not all shas expected (${actual_nshas} != ${nshas}) were found in `pwd`" >&2
      if [ ${actual_nshas} -lt ${nshas} ]; then
        # list the whole set of expected shas
        missing="`echo ${shas} |
                    space_to_newline_unique`"
        # Truncated shas that we found
        known="`echo \"${missing}\" |
                  sed 's/.*/s\/^&[0-9a-fA-F]*$\/&\//'`"
        # rule based on full and truncated shas
        known="`(
                  space_to_newline_unique <${TMP}${index}/shas
                  space_to_newline_unique <${TMP}${index}/shas |
                    sed \"${known}\"
                ) |
                  unique |
                  sed 's/.*/^&$/'`"
        # now subtract all knowns from set of expected
        missing="`echo \"${missing}\" |
                    grep --invert-match \"${known}\"
                    sed 's/^\([0-9a-fA-F]\{6,16\}\).*/\1.../'`"
        if [ -n "${missing}" ]; then
          echo "${RED}[    ERROR ]${NORMAL}     missing? `echo \"${missing}\" |
                   sed '2,$s/^/                          /'`" >&2
        fi
        if [ -n "${dup_shas}" ]; then
          echo "${RED}[    ERROR ]${NORMAL}  duplicates? `echo \"${dup_shas}\" |
                   sed '2,$s/^/                          /'`" >&2
        fi
      fi
      ret=1
    fi
  fi ||
    ret=${?}
  return ${ret}
}

TMP=`mktemp -d`/
echo "${ORANGE}[     INFO ]${NORMAL} Pass 1 ... Acquire tree information" >&2
index=0
for k in ${kernels}; do
  if [ ! -d ${k} ]; then
    echo "${RED}[    ERROR ]${NORMAL} Kernel directory ${k} does not exist!" >&2
    wait
    rm --recursive --force ${TMP}
    exit 1
  fi
  mkdir -p ${TMP}${index}
  realpath -m ${k} >${TMP}${index}/directory
  (
    cd ${k} &&
      find * -print -type f >${TMP}${index}/files
  )&
  if [ ${nshas} -gt 0 ]; then
    (
      cd ${k} &&
        (
          kernels=
          shas="`echo \"${shas}\" |
                 while read sha fullsha ; do
                   if [ -z ${fullsha} ]; then
                     fullsha=${sha}
                   fi
                   if ${GIT} merge-base --is-ancestor ${fullsha} HEAD 2>/dev/null; then
                     echo ${sha} ${fullsha}
                   else
                     echo ${sha} ${fullsha} >&9
                   fi
                 done`" &&
          sort_shas
        ) 9>&1 |
          while read sha fullsha; do
            if [ -z ${fullsha} ]; then
              fullsha=${sha}
            fi
            oneline="`${GIT} log --pretty=full --pretty=oneline --max-count=1 ${fullsha} 2>/dev/null`"
            if [ -n "${oneline}" ]; then
              echo "${sha} ${oneline}" >>${TMP}${index}/oneline.extra
              echo "${sha} ${oneline%%${SPACE}*}" >>${TMP}${index}/shas.extra
            fi
          done
    )&
  fi
  index=`expr ${index} + 1`
done
wait

# Delineate old and new content
cutline="--------"
# Skip any Android prefixes like ANDROID:, GKI: etc
subject_from_oneline_match="^\([0-9a-fA-F]*\)${SPACES}[0-9a-fA-F]*${SPACES}\([A-Z]*:${SPACE}*\)*\(.*\)"
# Truncate comment line removing and (comments)
strip_trailing_extras="s/${SPACES}am: [0-9a-fA-F]\{6,\}\$//
s/${SPACES}([^)]*)\$//"

echo "${ORANGE}[     INFO ]${NORMAL} Pass 2 ... Acquire alternate sha information by title matching" >&2
i=0
while [ ${i} -lt ${index} ]; do
  [ ! -s ${TMP}${i}/oneline ] ||
    sed --quiet \
        --expression "${strip_trailing_extras}" \
        --expression "s/${subject_from_oneline_match}/\1 \3/p" \
        ${TMP}${i}/oneline
  i=`expr ${i} + 1`
done |
  sort --unique >${TMP}titles

index1=0
while read sha1 title1; do
  index2=0
  while read sha2 title2; do
    if [ ${index1} -ge ${index2} ]; then
      index2=`expr ${index2} + 1`
      continue
    fi
    if [ "${title1}" = "${title2}" ]; then
      echo "${ORANGE}[  WARNING ]${NORMAL} ${sha1} and ${sha2} title the same (\"${title1}\")" >&2
    fi
    index2=`expr ${index2} + 1`
  done <${TMP}titles
  index1=`expr ${index1} + 1`
done <${TMP}titles

for f in ${TMP}[0-9]*/oneline; do
  if [ -s ${f} ]; then
    cat ${TMP}[0-9]*/oneline |
      unique >>${TMP}oneline
  fi
  break
done

index=0
for k in ${kernels}; do
  if [ -s ${TMP}${index}/shas ] &&
     [ `wc --lines <${TMP}${index}/shas` = ${nshas} ]; then
    # Nothing to see here
    index=`expr ${index} + 1`
    continue
  fi
  (
    first=true
    cd ${k} &&
    if [ -s ${TMP}${index}/oneline ]; then
      TITLES="`sed --quiet \
                   --expression \"${strip_trailing_extras}\" \
                   --expression \"s/${subject_from_oneline_match}/^\1 \3\$/p\" \
                   ${TMP}${index}/oneline |
                 string_to_regex`"
      grep --invert-match "${TITLES}" ${TMP}titles
    else
      cat ${TMP}titles
    fi |
      while read sha title; do
        ${GIT} log --pretty=full --pretty=oneline --grep="${title}" |
          grep --invert-match --max-count=1 'Merge remote-tracking branch\|Merge ".*"$\| am: [0-9a-fA-F]\{6,\}$' |
          sed "s/^/${sha} /"
      done |
      while read sha fullsha title; do
        if ${first}; then
          first=false
          if ${debug}; then
            echo ${cutline} ${index} >>${TMP}oneline
            echo ${cutline} ${index} >>${TMP}${index}/oneline
          fi
          echo ${cutline} ${index} >>${TMP}${index}/shas
        fi
        echo "${sha} ${fullsha} ${title}" >>${TMP}oneline
        echo "${sha} ${fullsha} ${title}" >>${TMP}${index}/oneline
        echo "${sha} ${fullsha}" >>${TMP}${index}/shas
      done
    [ -s ${TMP}${index}/shas -o ! -e ${TMP}${index}shas ] || rm ${TMP}${index}/shas
    [ -s ${TMP}${index}/oneline -o ! -e ${TMP}${index}oneline ] || rm ${TMP}${index}/oneline
    # re-sort them?
    if [ -s ${TMP}${index}/shas ] &&
         grep "^${cutline}\( [0-9]*\)*\$" ${TMP}${index}/shas >/dev/null; then
      shas="`grep --invert-match \"^${cutline}\( [0-9]*\)*\$\" ${TMP}${index}/shas`" &&
        sort_shas
    fi
  )&
  index=`expr ${index} + 1`
done
wait

# Pour through the commits and split them up

patch_files() {
  sed --quiet 's@^--- a/@@p'
}

BUG_INDEX=0001
if [ -z "${AUTHOR_EMAIL}" ]; then
  AUTHOR_EMAIL="`${USER}@google.com`"
fi

[ "USAGE: save_patch < patchcontent > touchedfilelist

Take an incoming patch from stdin, adjust content and save it in ${TMP},
and output the list of source files affected by the patch.

\${sha}          - commit sha reference source
\${fullsha}      - commit full sha source
\${bugs}         - list of reference bugs to add
\${AUTHOR_NAME}  - full name of author
\${AUTHOR_EMAIL} - email of author
\${BUG_INDEX}    - sequential bug index
\${TMP}          - temporary directory" ]
save_patch() {
  sha_source=${sha}
  if [ X"${sha}" = X"-" ]; then
    sha_source=stdin
  fi
  fullsha_source=${fullsha}
  if [ -z "${fullsha_source}" ]; then
    fullsha_shource=stdin
  fi
  BUGLIST=
  TMPFILE=${TMP}${BUG_INDEX}-${sha_source}.tmp
  sed "s/^Subject:${SPACES}[[]PATCH\(${SPACES}v[0-9]*\)\{,1\}\(${SPACES}[0-9]\{1,\}\/[0-9]\{1,\}\)\{,1\}[]]${SPACES}/Subject: /" |
    tee ${TMPFILE} |
    grep "from commit ${fullsha_source}" >/dev/null ||
  BUGLIST="(cherry picked from commit ${fullsha_source})"
  if [ -n "${BUGLIST}" ] ||
     ! grep "^Signed-off-by: ${AUTHOR_NAME} <${AUTHOR_EMAIL}>\$" ${TMPFILE} >/dev/null; then
    if [ -n "${BUGLIST}" ]; then
      BUGLIST="${BUGLIST}\\
"
    fi
    BUGLIST="${BUGLIST}Signed-off-by: ${AUTHOR_NAME} <${AUTHOR_EMAIL}>"
  fi
  for b in ${bugs}; do
    if ! grep -i "^Bug: ${b}\$" ${TMPFILE} >/dev/null; then
      if [ -n "${BUGLIST}" ]; then
        BUGLIST="${BUGLIST}\\
"
      fi
      BUGLIST="${BUGLIST}Bug: ${b}"
    fi
  done
  SCRIPT=
  if [ -n "${BUGLIST}" ]; then
    BUGLINE=$(grep --line-number '^diff ' ${TMPFILE} |
                sed --quiet 's/^\([0-9][0-9]*\):.*/\1/p' |
                head -1)
    if [ -n "${BUGLINE}" ]; then
      BUGLINE=$((BUGLINE - 1))
      SCRIPT="${BUGLINE}i ${BUGLIST}"
    fi
  fi
  if ! grep "^Subject:${SPACES}ANDROID:${SPACE}" ${TMPFILE} >/dev/null; then
    [ -z "${SCRIPT}" ] || SCRIPT="${SCRIPT}
"
    SCRIPT="${SCRIPT}s/^Subject:${SPACES}\([^A ${TAB}]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACES}\(A[^N]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACES}\(AN[^D]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACES}\(AND[^R]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACES}\(ANDR[^O]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACES}\(ANDRO[^I]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACES}\(ANDROI[^D]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACES}ANDROID${SPACE}/Subject: ANDROID: /
      s/^Subject:${SPACES}ANDROID\([^:]\)/Subject: ANDROID: \1/
      s/^Subject:${SPACE}\{2,\}ANDROID:/Subject: ANDROID:/"
  fi
  if ! grep "^Subject:.*${SPACE}GKI:${SPACE}" ${TMPFILE} >/dev/null; then
    [ -z "${SCRIPT}" ] || SCRIPT="${SCRIPT}
"
    SCRIPT="${SCRIPT}s/^Subject:${SPACES}ANDROID:${SPACES}\([^G ${TAB}]\)/Subject: ANDROID: GKI: \1/
      s/^Subject:${SPACES}ANDROID:${SPACES}\(G[^K]\)/Subject: ANDROID: GKI: \1/
      s/^Subject:${SPACES}ANDROID:${SPACES}\(GK[^I]\)/Subject: ANDROID: GKI: \1/
      s/^Subject:${SPACES}ANDROID:${SPACES}GKI${SPACE}/Subject: ANDROID: GKI: /
      s/^Subject:${SPACES}ANDROID:${SPACES}GKI\([^:]\)/Subject: ANDROID: GKI: \1/"
  fi
  [ -z "${SCRIPT}" ] || SCRIPT="${SCRIPT}
"
  SCRIPT="${SCRIPT}/^Subject:/ {
      N
      s/^\(Subject:.*\)\n /\1 /
    }"
  if [ -n "${RENAME_SED_SCRIPT}" ]; then
    SCRIPT="${SCRIPT}
            ${RENAME_SED_SCRIPT}"
  fi
  sed "${SCRIPT}" ${TMPFILE} |
    tee ${TMP}${BUG_INDEX}-${sha_source}.patch |
    patch_files |
    newline_to_space_unique |
    sed "s/^/${sha} ${fullsha_source} /"
  rm ${TMPFILE}
}

[ "USAGE: split_up_patch file... > adjustedcontent

Take an incoming patch from stdin, adjust content and copy it out
to stdout, slicing off the fragments that are not part of the file
list.

NB: We do not currently support patches that introduce new files

\${sha}          - commit sha reference source
\${fullsha}      - commit full sha source
\${AUTHOR_NAME}  - full name of author
\${AUTHOR_EMAIL} - email of author
\${TMP}          - temporary directory" ]
split_up_patch() {
  sed ": loop1
       `echo $* |
        space_to_newline_unique |
        string_to_regex |
        sed 's@/@\\\\/@g
             s/.*/\/^diff .*a\\\\\/& b\\\\\/& *$\/ b ok/'`
       /^diff${SPACES}.*a\// {
         : loop2
         N
         s/.*\n//
         /^\$/ b loop1
         /^diff${SPACES}.*a\// b loop1
         b loop2
       }
       : ok
       /^Subject:${SPACE}/ {
         N
         s/^Subject:${SPACES}\(ANDROID:${SPACES}\)\{0,1\}\(GKI:${SPACES}\)\{0,1\}\([-_a-zA-Z]*:${SPACES}\|[[][-_a-zA-Z]*[]]${SPACES}\)\{0,\}\([^\n]*\)\(\n\)\([^\n]*\)\$/Subject: ANDROID: GKI: \3Implement <edit> was \4\5\5Partial cherry picked from commit ${fullsha}\5(\"\3\4\")\5\5Original commit message: <edit>\5\6/
       }
       s/^From: .*/From: ${AUTHOR_NAME} <${AUTHOR_EMAIL}>/
       s/^(cherry[- ]\(picked from commit \)/(partial cherry \1/
       /^Change-Id:${SPACES}I/ {
         s/[Ff]\$/0/
         t skip
         s/[Ee]\$/f/
         t skip
         s/[Dd]\$/e/
         t skip
         s/[Cc]\$/d/
         t skip
         s/[Bb]\$/c/
         t skip
         s/[Aa]\$/b/
         t skip
         s/9\$/a/
         t skip
         s/8\$/9/
         t skip
         s/7\$/8/
         t skip
         s/6\$/7/
         t skip
         s/5\$/6/
         t skip
         s/4\$/5/
         t skip
         s/3\$/4/
         t skip
         s/2\$/3/
         t skip
         s/1\$/2/
         t skip
         s/0\$/1/
         t skip
         d
         : skip
       }" ${TMP}[0-9][0-9][0-9][0-9]-${sha}.patch
}

[ "USAGE: print_index value >stdout

Convert a number to a patch index" ]
print_index() {
  printf "%04u" `echo ${1} | sed 's/^0*//'`
}

if [ ${nshas} -le 0 ]; then
  echo "${ORANGE}[     INFO ]${NORMAL} Pass 3 ... Reading incoming patch" >&2
  sha=-
  fullsha=
  save_patch
else
  echo "${ORANGE}[     INFO ]${NORMAL} Pass 3 ... Reading incoming shas" >&2
  echo "${shas}" |
    while read sha; do
      index=0
      for k in ${kernels}; do
        fullsha=
        if [ -s ${TMP}${index}/shas ]; then
          fullsha=`cat ${TMP}${index}/shas 2>/dev/null |
                     sed --quiet "s/^${sha}${SPACES}\([0-9a-fA-F]*\)\$/\1/p" |
                     unique`
        fi
        if [ -z "${fullsha}" ]; then
          if [ -s ${TMP}${index}/shas.extra ]; then
            fullsha=`cat ${TMP}${index}/shas.extra 2>/dev/null |
                       sed --quiet "s/^${sha}${SPACES}\([0-9a-fA-F]*\)\$/\1/p" |
                       unique`
          fi
        fi
        if [ -n "${fullsha}" ]; then
          git show --pretty=email ${fullsha} |
            save_patch
          break
        fi
        index=`expr ${index} + 1`
      done
      BUG_INDEX=`expr ${BUG_INDEX} + 1`
      BUG_INDEX=`print_index ${BUG_INDEX}`
    done
fi |
  while read sha fullsha files; do
    regex="`echo ${files} |
              space_to_newline_unique |
              string_to_regex |
              sed 's/.*/^&$/'`"
    nfiles=`echo ${files} | wc --words`
    index=0
    for k in ${kernels}; do
      if [ -s ${TMP}${index}/shas ] &&
           grep "^${sha}" ${TMP}${index}/shas >/dev/null; then
        index=`expr ${index} + 1`
        continue
      fi
      matches="`grep \"${regex}\" ${TMP}${index}/files`"
      if [ -z "${matches}" ]; then
        index=`expr ${index} + 1`
        continue
      fi
      line="`index=0
             for k in ${kernels}; do
               if grep --line-number --max-count=1 \"^${sha}\" ${TMP}${index}/shas; then
                 break
               fi
             done |
               sed --quiet 's/^\([0-9]*\):.*/\1/p'`"
      if [ -z "${line}" ]; then
        line=`cd ${TMP} &&
                ls -1 [0-9][0-9][0-9][0-9]-${sha}.patch |
                head -1`
        line=${line%-${sha}.patch}
      fi
      line=`print_index ${line}`
      echo "${ORANGE}[     INFO ]${NORMAL} ${index}/${line}-${sha} `cat ${TMP}${index}/directory`" ${files} >&2
      rm --force ${TMP}${index}/${line}-${sha}.patch
      nmatches=`echo ${matches} | wc --words`
      if [ ${nmatches} -ge ${nfiles} ]; then
        ln --symbolic ${TMP}[0-9][0-9][0-9][0-9]-${sha}.patch ${TMP}${index}/${line}-${sha}.patch
      else
        split_up_patch ${matches} >${TMP}${index}/${line}-${sha}.patch
      fi
      index=`expr ${index} + 1`
    done
  done

if ${debug}; then
  echo "${BLUE}[     INFO ]${NORMAL} All collected data:" >&2
  ls -l --recursive ${TMP} |
    sed "s@`string_to_regex ${TMP}`@.../@g" >&2
  n=0
  if [ -s "${TMP}titles" ]; then
    n=`wc --lines <${TMP}titles`
  fi
  echo "${BLUE}[     INFO ]${NORMAL} All (${n}) titles:" >&2
  if [ -s "${TMP}titles" ]; then
    cat ${TMP}titles >&2
  fi
  n=0
  if [ -s "${TMP}oneline" ]; then
    n=`wc --lines <${TMP}oneline`
  fi
  echo "${BLUE}[     INFO ]${NORMAL} All (${n}) onelines:" >&2
  if [ -s "${TMP}oneline" ]; then
    cat ${TMP}oneline >&2
  fi
  i=0
  while [ ${i} -lt ${index} ]; do
    if [ -s ${TMP}${i}/shas ]; then
      n=`wc --lines <${TMP}${i}/shas`
      echo "${BLUE}[     INFO ]${NORMAL} `cat ${TMP}${i}/directory` (${n}) shas:" >&2
      cat ${TMP}${i}/shas >&2
    fi
    if [ -s ${TMP}${i}/shas.extra ]; then
      n=`wc --lines <${TMP}${i}/shas.extra`
      echo "${BLUE}[     INFO ]${NORMAL} `cat ${TMP}${i}/directory` (${n}) branch shas:" >&2
      cat ${TMP}${i}/shas.extra >&2
    fi
    if [ -s ${TMP}${i}/oneline ]; then
      n=`wc --lines <${TMP}${i}/oneline` 2>/dev/null
      echo "${BLUE}[     INFO ]${NORMAL} `cat ${TMP}${i}/directory` (${n}) onelines:" >&2
      cat ${TMP}${i}/oneline >&2
    fi
    if [ -s ${TMP}${i}/oneline.extra ]; then
      n=`wc --lines <${TMP}${i}/oneline.extra` 2>/dev/null
      echo "${BLUE}[     INFO ]${NORMAL} `cat ${TMP}${i}/directory` (${n}) branch onelines:" >&2
      cat ${TMP}${i}/oneline.extra >&2
    fi
    i=`expr ${i} + 1`
  done
fi

echo "${ORANGE}[     INFO ]${NORMAL} Pass 4 ... Generate git am -3 -k patch files" >&2
# dump suitable for git am
index=0
for k in ${kernels}; do
  for f in ${TMP}${index}/[0-9][0-9][0-9][0-9]-*.patch; do
    destination="`cat ${TMP}${index}/directory`/split.patch"
    rm --force ${destination}
    short_destination=${destination}
    if [ "${destination}" != "${destination#${HOME}/}" ]; then
      short_destination='~/'${destination#${HOME}/}
    fi
    if [ -s ${f} ]; then
      cat ${TMP}${index}/[0-9][0-9][0-9][0-9]-*.patch >${destination}
      echo "${ORANGE}[     INFO ]${NORMAL} Generated ${short_destination}" >&2
      if ${debug}; then
        echo ${destination}
      fi
    else
      echo "${ORANGE}[     INFO ]${NORMAL} No patches for ${short_destination%split.patch}" >&2
    fi
    break
  done
  index=`expr ${index} + 1`
done |
  xargs --no-run-if-empty ls -l >&2

rm --recursive --force ${TMP}

echo "${GREEN}[        OK ]${NORMAL} Done" >&2
