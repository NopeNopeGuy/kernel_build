{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2a1e3e63_66d94ff0",
        "filename": "kleaf/hermetic_tools.bzl",
        "patchSetId": 15
      },
      "lineNbr": 160,
      "author": {
        "id": 1961395
      },
      "writtenOn": "2024-05-13T13:58:56Z",
      "side": 1,
      "message": "This will now include the internal links, but I think it\u0027s WAI as they are now part of the outputs here, right?",
      "range": {
        "startLine": 160,
        "startChar": 35,
        "endLine": 160,
        "endChar": 46
      },
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a30a0770_b53e8b84",
        "filename": "kleaf/hermetic_tools.bzl",
        "patchSetId": 15
      },
      "lineNbr": 160,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2024-05-13T18:57:44Z",
      "side": 1,
      "message": "Yes.\n\nIt is intentional to put the symlinks in default outputs. Otherwise, `bazel clean \u0026\u0026 bazel build //build/kernel:hermetic-tools` will create an rsync / tar binary that can\u0027t be used because the \"internal_symlink\" is not created.",
      "parentUuid": "2a1e3e63_66d94ff0",
      "range": {
        "startLine": 160,
        "startChar": 35,
        "endLine": 160,
        "endChar": 46
      },
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b330ce4_c53b8496",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 66,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2024-05-13T13:21:52Z",
      "side": 1,
      "message": "Sorry for the back and forth, I am not sure we need this entire utility. Can\u0027t we just do `\u003c\u003c strerror(errno)` at the die_error() call sites instead?. Look at the suggestion, perhaps that is all we need here for this rather simple utility.",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 66,
        "endChar": 2
      },
      "fixSuggestions": [
        {
          "fixId": "fea8ee87_dcc37321",
          "description": "prompt_to_edit API",
          "replacements": [
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 44,
                "startChar": 0,
                "endLine": 75,
                "endChar": 0
              },
              "replacement": ""
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 81,
                "startChar": 0,
                "endLine": 82,
                "endChar": 0
              },
              "replacement": "    std::cerr \u003c\u003c \"ERROR: read_symlink /proc/self/exe: \" \u003c\u003c ec.message()\n              \u003c\u003c std::endl;\n    exit(1);\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 91,
                "startChar": 0,
                "endLine": 92,
                "endChar": 0
              },
              "replacement": "    std::cerr \u003c\u003c \"ERROR: Unable to open \" \u003c\u003c path \u003c\u003c \": \" \u003c\u003c strerror(errno)\n              \u003c\u003c std::endl;\n    exit(1);\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 111,
                "startChar": 0,
                "endLine": 112,
                "endChar": 0
              },
              "replacement": "      std::cerr \u003c\u003c \"ERROR: execv: \" \u003c\u003c executable \u003c\u003c \": \" \u003c\u003c strerror(errno)\n                \u003c\u003c std::endl;\n      exit(1);\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 113,
                "startChar": 0,
                "endLine": 114,
                "endChar": 0
              },
              "replacement": "    std::cerr \u003c\u003c \"ERROR: execv returns!\" \u003c\u003c std::endl;\n    exit(1);\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 123,
                "startChar": 0,
                "endLine": 124,
                "endChar": 0
              },
              "replacement": "    std::cerr \u003c\u003c \"ERROR: argc \u003d\u003d \" \u003c\u003c argc \u003c\u003c \" \u003c 1\" \u003c\u003c std::endl;\n    exit(1);\n"
            }
          ]
        }
      ],
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "422d8937_eeaf9dfb",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 66,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2024-05-13T18:57:44Z",
      "side": 1,
      "message": "If there is an I/O error when writing to std::cerr, errno will be mutated. This class is to ensure we are writing the correct errno. IMO it is bad practice to use strerror() without ensuring that the errno is saved **right next** to the syscall. \n\nIn other words, I do not want to encourage the usage of `std::cerr \u003c\u003c \"...\" \u003c\u003c strerror(errno)` because someone in the future may copy the code and write `std::cerr \u003c\u003c \"WARNING: ...\" \u003c\u003c strerror(errno)` without `exit(1)`, creating confusing and possibly incorrect. warning messages.",
      "parentUuid": "6b330ce4_c53b8496",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 66,
        "endChar": 2
      },
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3956e72_7e6069b3",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 66,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2024-05-13T19:19:43Z",
      "side": 1,
      "message": "Sorry, my last paragraph should be:\n\nIn other words, I do not want to encourage the usage of `std::cerr \u003c\u003c \"...\" \u003c\u003c strerror(errno)` because the errno at that point could be incorrect.\n\nIt could\u0027ve been:\n\n```\nint saved_errno \u003d errno;\nstd::cerr \u003c\u003c \"...\" \u003c\u003c strerror(saved_errno);\nexit(1);\n```\n\nbut I would write a class for this if it is repetitive.",
      "parentUuid": "422d8937_eeaf9dfb",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 66,
        "endChar": 2
      },
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "171ba5b3_126bd73a",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 116,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2024-05-13T13:21:52Z",
      "side": 1,
      "message": "I think that can just be a function\n\n`[[noreturn]] void exec(const std::filesystem::path\u0026 executable);`",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 116,
        "endChar": 0
      },
      "fixSuggestions": [
        {
          "fixId": "5370f396_77976196",
          "description": "prompt_to_edit API",
          "replacements": [
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 100,
                "startChar": 0,
                "endLine": 109,
                "endChar": 0
              },
              "replacement": "// Helper function that manages the constructed argv.\n[[noreturn]] void exec(const std::filesystem::path\u0026 executable,\n                       std::vector\u003cstd::string\u003e\u0026 argv) {\n  std::vector\u003cchar*\u003e cargv;\n  for (auto\u0026 arg : argv) {\n    cargv.push_back(arg.data());\n  }\n  cargv.push_back(nullptr);\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 110,
                "startChar": 0,
                "endLine": 114,
                "endChar": 0
              },
              "replacement": "  if (-1 !\u003d execv(executable.c_str(), cargv.data())) {\n    die_error() \u003c\u003c \"ERROR: execv: \" \u003c\u003c executable;\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 115,
                "startChar": 0,
                "endLine": 116,
                "endChar": 0
              },
              "replacement": "  die() \u003c\u003c \"ERROR: execv returns!\";\n}\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 130,
                "startChar": 0,
                "endLine": 131,
                "endChar": 0
              },
              "replacement": "  std::vector\u003cstd::string\u003e new_argv;\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 141,
                "startChar": 0,
                "endLine": 142,
                "endChar": 0
              },
              "replacement": "  exec(real_executable, new_argv);\n"
            }
          ]
        }
      ],
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e596ce00_a3909622",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 116,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2024-05-13T19:19:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "171ba5b3_126bd73a",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 116,
        "endChar": 0
      },
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "defa740f_ee1432e3",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 130,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2024-05-13T13:21:52Z",
      "side": 1,
      "message": "why not build the `std::vector\u003cchar*\u003e` directly?",
      "range": {
        "startLine": 130,
        "startChar": 0,
        "endLine": 130,
        "endChar": 22
      },
      "fixSuggestions": [
        {
          "fixId": "8968de64_aba8ac91",
          "description": "prompt_to_edit API",
          "replacements": [
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 99,
                "startChar": 0,
                "endLine": 116,
                "endChar": 0
              },
              "replacement": ""
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 130,
                "startChar": 0,
                "endLine": 132,
                "endChar": 0
              },
              "replacement": "  std::vector\u003cchar*\u003e new_argv;\n  new_argv.push_back(real_executable.c_str());\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 134,
                "startChar": 0,
                "endLine": 135,
                "endChar": 0
              },
              "replacement": "    new_argv.push_back(argv[i].c_str());\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 139,
                "startChar": 0,
                "endLine": 140,
                "endChar": 0
              },
              "replacement": "  for (auto\u0026 arg : preset_args) {\n    new_argv.push_back(arg.c_str());\n  }\n\n  new_argv.push_back(nullptr);\n"
            },
            {
              "path": "kleaf/impl/arg_wrapper.cpp",
              "range": {
                "startLine": 141,
                "startChar": 0,
                "endLine": 142,
                "endChar": 0
              },
              "replacement": "  if (-1 !\u003d execv(real_executable.c_str(), new_argv.data())) {\n    die_error() \u003c\u003c \"ERROR: execv: \" \u003c\u003c real_executable;\n  }\n  die() \u003c\u003c \"ERROR: execv returns!\";\n"
            }
          ]
        }
      ],
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6767138e_3563c79e",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 130,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2024-05-13T19:19:43Z",
      "side": 1,
      "message": "If I don\u0027t create a separate std::vector\u003cstd::string\u003e to hold the string buffers:\n\n- `real_executable` needs to be declared explicitly as a string (now it is an implicit fs::path)\n- I can\u0027t do `new_argv.insert(new_argv.end(), preset_args.begin(), preset_args.end());` but instead use a for-loop\n\nI think it is easier to understand the memory management by ensuring there\u0027s a backing vector\u003cstring\u003e, instead of constructing a vector\u003cchar*\u003e where the pointers come from different places",
      "parentUuid": "defa740f_ee1432e3",
      "range": {
        "startLine": 130,
        "startChar": 0,
        "endLine": 130,
        "endChar": 22
      },
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0cd1d92_af9b53fb",
        "filename": "kleaf/impl/arg_wrapper.cpp",
        "patchSetId": 15
      },
      "lineNbr": 130,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2024-05-13T19:46:45Z",
      "side": 1,
      "message": "For the second one I could also use \n\n```\n  std::transform(preset_args.begin(), preset_args.end(),\n                 std::back_inserter(new_argv),\n                 static_cast\u003cchar* (std::string::*)()\u003e(\u0026std::string::data));\n```\n\nBut I don\u0027t think it is better than using a for loop (especially with the cast to disambiguate the two string::data() overloads)",
      "parentUuid": "6767138e_3563c79e",
      "range": {
        "startLine": 130,
        "startChar": 0,
        "endLine": 130,
        "endChar": 22
      },
      "revId": "0cea7798c7f6d99852358622f099bb5e4bad199c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}