{
  "comments": [
    {
      "key": {
        "uuid": "b66508d8_13e28b81",
        "filename": "abi/kmi_defines.py",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2020-02-07T16:02:43Z",
      "side": 1,
      "message": "I just learned that typing has an Optional [1] type that lets you either return None or a proper type. In this case, you would apply this to the function signature:\n\n  def get_src_ccline_deps(obj: str) -\u003e Optional[Tuple[str, str, List[str]]]:\n\nNow you return either a tuple or None. To make this look less ugly, you could use a typed named tuple [1]:\n\n  from typing import NamedTuple\n  class CCLineAnalysis(NamedTuple):\n      src: str\n      cc_line: str\n      dependencies: List[str]\n\nAnd your function signature is then:\n\n  def get_src_ccline_deps(obj: str) -\u003e Optional[CCLineAnalysis]:\n\nAnd your callers have to just check for whether there is a value. Also, callers don\u0027t have to check each single value and they can\u0027t misuse the return value as string without checking.\n\nPlease apply this pattern and create follow up commits to correct that behaviour elsewhere (e.g. line 162)\n\n\n[1] https://docs.python.org/3.8/library/typing.html#typing.Optional\n[2] https://docs.python.org/3.8/library/typing.html#typing.NamedTuple",
      "range": {
        "startLine": 193,
        "startChar": 8,
        "endLine": 193,
        "endChar": 25
      },
      "revId": "2d5fd3cab9b9762d1ac2033094b6b670d7ca4ed8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8abab28_cd47ab2c",
        "filename": "abi/kmi_defines.py",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1428004
      },
      "writtenOn": "2020-02-14T02:36:24Z",
      "side": 1,
      "message": "I have changed all the code to use Optional and None from the following commit forwards, there was too much change between this one and the next one and all the other commits that had pending to do that work on this one.\n\nI chose not to use NamedTuple, its too obscure.  Functions have argument lists, when called customarily by passing an argument list without the argument names the programmer has to understand the order of the arguments.  The same with tuples when returned by a function.  In the very few uses of this program of tuples using a NamedTuple adds too much noise, returning them in the right order and having the caller know the order is no different than a function caller having to know the order of the arguments.",
      "parentUuid": "b66508d8_13e28b81",
      "range": {
        "startLine": 193,
        "startChar": 8,
        "endLine": 193,
        "endChar": 25
      },
      "revId": "2d5fd3cab9b9762d1ac2033094b6b670d7ca4ed8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22fabb62_bf1989e5",
        "filename": "abi/kmi_defines.py",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2020-02-14T15:30:09Z",
      "side": 1,
      "message": "I strongly disagree. Please elaborate on \"its too obscure\"? NamedTuple is a commonly used method to capture simple types. We should also do so. And I do not see anything obscure in my example above. It is properly typed and with the Python3 syntax it even looks like a C struct ...\nhttps://github.com/search?l\u003dPython\u0026q\u003dNamedTuple\u0026type\u003dCode\n\nAnd from an API perspective: the less the user of an API needs to know, the less they can do wrong. So, I do not agree with the statement and would rather add that: if it is hard for users to pass arguments in the wrong order, then you should rather use an object there as well.\n\nNamedTuple and Optional play so well together ...",
      "parentUuid": "d8abab28_cd47ab2c",
      "range": {
        "startLine": 193,
        "startChar": 8,
        "endLine": 193,
        "endChar": 25
      },
      "revId": "2d5fd3cab9b9762d1ac2033094b6b670d7ca4ed8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2da181e_0628dbca",
        "filename": "abi/kmi_defines.py",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1428004
      },
      "writtenOn": "2020-02-14T20:58:58Z",
      "side": 1,
      "message": "Thank you for asking me to revisit this.\n\nLet me try nicer words.\n\nWhen I say \"too obscure\" I mean that it requires\nmore indirection by the code reader:\n\nCode reading indirection:\n- The reader has to understand typing.NamedTuple\n  (not a native language construct).\n- The reader has to find the declaration of the\n  NamedTuple, presumably it would be immediately\n  above the function that uses it as its return\n  value (but it still requires examining 3 places\n  instead of 2).\n\nConceptual complexity when compared to the base\nPython language:\n- Some introspection code must be running where the\n  NamedTyple.__init__() finds the data declarations\n  and generates a constructor (how that might work\n  is not obvious to somebody who only understands\n  the base language)\n- So from the code reader the NamedTuple is effectively\n  extending the language by doing non obvious things\n- The comparison with argument lists is completely\n  valid.  I would not turn every function with 2 or\n  more arguments into a function that takes a NamedTuple\n  as its arguments (or that strictly requires the use\n  of keyword arguments), it would add too much noise.\n\nI agree that the syntax is nice.\n\nIt makes me actually want to declare every field\nof my objects explicitly so that the code reader\ndoesn\u0027t have to derive their knowledge about them\nfrom reading the code of the class (presumably all\nset in the __init__() but any member can add more\ndata to the object, which to me is quite special\nin its dynamism).\n\nSo two questions:\n- Can I do this kind of change on top of the last\n  commit?  Doing it deep under about 10 later commits\n  is too hard and wasteful as the code was mostly\n  ready to go during the prior weeks.\n- Should all data members of classes be declared\n  at the class declaration level?  Is that good for\n  code quality / review / understanding or is that\n  not proper Python style?",
      "parentUuid": "22fabb62_bf1989e5",
      "range": {
        "startLine": 193,
        "startChar": 8,
        "endLine": 193,
        "endChar": 25
      },
      "revId": "2d5fd3cab9b9762d1ac2033094b6b670d7ca4ed8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d7787da_3a608865",
        "filename": "abi/kmi_defines.py",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2020-02-18T15:06:48Z",
      "side": 1,
      "message": "I agree to make this change on top of the stack. Please merge this one after this has been proposed as new change.\n\nI consider NameTuple part of the common (native?) language usage. Another alternative that also works nicely in python2 is the (external!) library attr, where a lot of the syntax and inspiration seems to come from. Whether this particular code will produce a significant performance overhead needs to be measured and can be rightfully replaced if that is the case. In any other case I would give readability, testability and (API) usability the prio.\n\nCareful with the declaration location, members declared at class level are class members and shared across instances. https://docs.python.org/3.7/tutorial/classes.html#class-and-instance-variables",
      "parentUuid": "b2da181e_0628dbca",
      "range": {
        "startLine": 193,
        "startChar": 8,
        "endLine": 193,
        "endChar": 25
      },
      "revId": "2d5fd3cab9b9762d1ac2033094b6b670d7ca4ed8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}