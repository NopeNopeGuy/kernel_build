{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "657854f0_9bf298a1",
        "filename": "abi/extract_symbols",
        "patchSetId": 2
      },
      "lineNbr": 225,
      "author": {
        "id": 1557540
      },
      "writtenOn": "2022-09-26T17:35:18Z",
      "side": 1,
      "message": "What\u0027s the reasoning behind using `llvm-strings`? I would recommend using `modinfo -F signature MODULENAME`. And if you wanted to go a step further, you could verify the module signature to see if it\u0027s a GKI module or not.",
      "range": {
        "startLine": 225,
        "startChar": 34,
        "endLine": 225,
        "endChar": 47
      },
      "revId": "b9a0ba5057a33019ddb0c20fc71c2b7fac0baf3d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e26947e_114aa7cf",
        "filename": "abi/extract_symbols",
        "patchSetId": 2
      },
      "lineNbr": 225,
      "author": {
        "id": 1889091
      },
      "writtenOn": "2022-09-26T20:13:15Z",
      "side": 1,
      "message": "Reasoning: https://android-review.googlesource.com/c/kernel/build/+/2221377/comment/0cf0e5cb_bdbd9702/\n\nNo we don\u0027t want to go to the step further and keep it simple as singed module as GKI and unsigned module as other with others can\u0027t sign their modules. The reason being this will require us to hold on to the key pair and make it available to partners for them to able to successfully update their symbol list changes. Anything which requires us to hold on to the key pair defeats the purpose as others can use it and sign their modules to imposter as GKI module. There is a big key management aspect to it as well.",
      "parentUuid": "657854f0_9bf298a1",
      "range": {
        "startLine": 225,
        "startChar": 34,
        "endLine": 225,
        "endChar": 47
      },
      "revId": "b9a0ba5057a33019ddb0c20fc71c2b7fac0baf3d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bbbc596_51564144",
        "filename": "abi/extract_symbols",
        "patchSetId": 2
      },
      "lineNbr": 225,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2022-09-27T15:17:33Z",
      "side": 1,
      "message": "But for verification you would only need the public key part that is anyway part of the kernel binary ...",
      "parentUuid": "3e26947e_114aa7cf",
      "range": {
        "startLine": 225,
        "startChar": 34,
        "endLine": 225,
        "endChar": 47
      },
      "revId": "b9a0ba5057a33019ddb0c20fc71c2b7fac0baf3d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb6a1ba0_4eea6b0b",
        "filename": "abi/extract_symbols",
        "patchSetId": 2
      },
      "lineNbr": 225,
      "author": {
        "id": 1889091
      },
      "writtenOn": "2022-09-27T19:08:54Z",
      "side": 1,
      "message": "Thanks for the review.\n\nYes, but we are using the build time generated key pair; so with every GKI image we need to hold onto that public key make it available for the vendors to use during their build so they can generate symbol list. I don\u0027t think the logistics required for key management is worth just to partition the modules. We don\u0027t get anything extra out of verifying signature during the build to partition the modules. If someone try to gimmick it then they won\u0027t have working device at runtime; so there is no motivation for anyone to gimmick it either.",
      "parentUuid": "2bbbc596_51564144",
      "range": {
        "startLine": 225,
        "startChar": 34,
        "endLine": 225,
        "endChar": 47
      },
      "revId": "b9a0ba5057a33019ddb0c20fc71c2b7fac0baf3d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2caba25_3d5ad38b",
        "filename": "abi/extract_symbols",
        "patchSetId": 2
      },
      "lineNbr": 225,
      "author": {
        "id": 1402878
      },
      "writtenOn": "2022-09-28T15:14:00Z",
      "side": 1,
      "message": "The public key can be extracted from `vmlinux`, so technically it is available wherever `vmlinux` is available: `scripts/extract-sys-certs.pl`. Similarly, the module signature can be extracted: `scripts/extract-module-sig.pl`.\n\nWhile verification is nice (and possible), I agree that we do not absolutely need this here for this purpose of partitioning symbols. \n\nThough, if somebody mixes build artifacts wrongly and happens to accidentally put in signed (GKI) modules from a wrong build (mixed build mess up), this could be flagged at this stage. But again, that is perhaps another check elsewhere to check the integrity of a GKI+GKI_Modules+Vendor_Modules distribution.",
      "parentUuid": "eb6a1ba0_4eea6b0b",
      "range": {
        "startLine": 225,
        "startChar": 34,
        "endLine": 225,
        "endChar": 47
      },
      "revId": "b9a0ba5057a33019ddb0c20fc71c2b7fac0baf3d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2814ff21_f318c9fb",
        "filename": "abi/extract_symbols",
        "patchSetId": 2
      },
      "lineNbr": 225,
      "author": {
        "id": 1889091
      },
      "writtenOn": "2022-09-28T20:58:33Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b2caba25_3d5ad38b",
      "range": {
        "startLine": 225,
        "startChar": 34,
        "endLine": 225,
        "endChar": 47
      },
      "revId": "b9a0ba5057a33019ddb0c20fc71c2b7fac0baf3d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}