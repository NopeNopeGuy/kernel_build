{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0cf0e5cb_bdbd9702",
        "filename": "abi/extract_symbols",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 1889091
      },
      "writtenOn": "2022-09-21T06:40:09Z",
      "side": 1,
      "message": "I differed from `modinfo` based approach to check whether a module is signed or not because of these reasons:\n\n1. Every signed module has last string as \"~Module signature appended~\\n\". `llvm-strings` is already available as part of our prebuilts where as `modinfo` needs to be added to keep our build system self contained.\n\n2. Initially I spent lot of time to get the `modinfo` working with python\u0027s `subprocess.run()` and `subprocess.check_output()` on my desktop before finding and settling with `llvm-strings` approach. It doesn\u0027t give error but output is always empty with return code as 0. However, `os.system()` does work but again `llvm-strings` is more efficient.\n\nThis works:\n\n```\ncmd \u003d \"modinfo -F signer \" + module\nos.system(cmd)\n```\n\nThese don\u0027t work:\n\n```\nmodinfo_result \u003d subprocess.run([\"/usr/sbin/modinfo\", \"-F signer\", module], capture_output\u003dTrue, check\u003dTrue)\n```\n\n```\nout \u003d subprocess.check_output([\"/usr/sbin/modinfo\", \"-F signer\", module],\n                                stderr\u003dsubprocess.DEVNULL).decode(\"ascii\")\n```\n\nMy guess is Python\u0027s `subprocess` doesn\u0027t work with program name as symbolic link as `insmod`, `rmmmod` and `modinfo` are symbolic link to `/bin/kmod` and depending on the link name `/bin/kmod` changes its behavior.",
      "revId": "5dde06c4a4c169795b207964a3f29199379e8ff8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}