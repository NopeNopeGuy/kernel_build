{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "82e111fe_c33477d6",
        "filename": "kleaf/impl/kernel_module.bzl",
        "patchSetId": 35
      },
      "lineNbr": 247,
      "author": {
        "id": 1066075
      },
      "writtenOn": "2022-09-19T12:05:41Z",
      "side": 1,
      "message": "What is the benefit of using a target_group here?\n\nIt appears that you are recreating some functionality in Starlark that Bazel offers natively (e.g. requiring that a target have a specific set of providers)\n\nYou also seem to put references to ConfiguredTarget objects in providers; this, by itself, works, but it\u0027s also a little strange. The Bazelic way is to aggregate all the information you need at every node in the dependency graph. In addition to being \"Bazelic\", it\u0027s also not O(n^2): as it is, if you have a dependency chain of `kernel_module` rules, the bottom-most one would process one provider, the second from the bottom, two, etc.\n\nFor example, instead of saying (like below) \"for dep in every transitive dependency, collect its DdkHeadersInfo then iterate over the headers in them to construct transitive_inputs\", you\u0027d add a \"set of transitive headers\" field to DdkHeadersInfo and use that. Then you wouldn\u0027t need all the DdkHeadersInfo objects from your transitive closure, only the direct ones.\n\nThis might also obviate the need for target_group?\n\nA quick look at DdkHeadersInfo in `ddk_headers.bzl` indicates that `DdkHeaders.files` is already the transitive headers. But then why do you need to look at your transitive DdkHeaderInfo providers?",
      "range": {
        "startLine": 247,
        "startChar": 5,
        "endLine": 247,
        "endChar": 53
      },
      "revId": "52288610ea611611a7ea8bb1b3424e881483065b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d6b7726_4487f78c",
        "filename": "kleaf/impl/kernel_module.bzl",
        "patchSetId": 35
      },
      "lineNbr": 247,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2022-09-19T22:55:00Z",
      "side": 1,
      "message": "\u003e\u003e\u003e WALL OF TEXT WARNING \u003c\u003c\u003c\n\nThe use of `target_group` allows me to do CL:2201118 and CL:2201916. As the comment says, I want a filegroup, but for targets so that a dependent target also sees all providers of targets in the group.\n\nTake the two CLs for example. I want to have `slider_ddk_modules_install` to say:\n\n```\nkernel_modules \u003d [\"//...:nfc\"]\n```\n\n... that is effectively equivalent to ...\n\n```\nkernel_modules \u003d [\"//...:st21nfc\", \"//...:ese/st33spi\", \"//...:ese/st54spi\"]\n```\n\nkernel_modules_install requests `KernelModuleInfo` from its `kernel_modules` attribute.\n\nThis is just an example. I might want to put a `target_group` of `kernel_modules` in the `deps` of a `kernel_module` too, which requests `KernelEnvInfo`, `DdkHeadersInfo` as well. (KernelEnvInfo has a list[File] which needs to be converted to depset too, I know -\u003e b/247624301)\n\n\u003e You also seem to put references to ConfiguredTarget objects in providers; this, by itself, works, but it\u0027s also a little strange. The Bazelic way is to aggregate all the information you need at every node in the dependency graph.\n\nIndeed, there are many examples of doing this in Kleaf project. I\u0027ll clean this up with b/247622808.\n\nIs there any text in the Bazel documentation to discourage people from doing this?\n\n\u003e A quick look at DdkHeadersInfo in ddk_headers.bzl indicates that DdkHeaders.files is already the transitive headers. But then why do you need to look at your transitive DdkHeaderInfo providers?\n\nI think you are suggesting to create a rule that exports DdkHeadersInfo as the merged info. I assume you are referring to this solution:\n\n```\ndef _kernel_module_group_impl(ctx):\n  return [\n    DdkHeadersInfo(\n      files \u003d depset(transitive \u003d [target[DdkHeadersInfo].files for target in ctx.attr.srcs),\n      includes \u003d \u003csame, merge ctx.attr.srcs\u003e\n    ),\n    # Other infos\n  ]\nkernel_module_group \u003d rule(\n  impl \u003d _kernel_module_group_impl,\n  attrs \u003d {\"srcs\": attr.label_list(providers \u003d [DdkHeadersInfo, ...])},\n)\n```\n\n```\nkernel_module(name \u003d \"a\")\nkernel_module(name \u003d \"b\")\n\nkernel_modules_install(name \u003d \"x\", kernel_modules \u003d [\"a\", \"b\"])\n# becomes\nkernel_module_group(name \u003d \"group\", srcs \u003d [\"a\", \"b\"])\nkernel_modules_install(name \u003d \"x\", kernel_modules \u003d [\"group\"])\n```\n\nThis solution:\n\n- Is specific to kernel_module / ddk_module\u0027s. Unlike target_group, I can\u0027t use it for other rules with other infos.\n  - This means if the providers that kernel_module exports changes, kernel_module_group also need to change.\n- Does not work for other infos. See below.\n\nFor example, a `kernel_module` also exports `KernelUnstrippedModulesInfo(directory: File)`, `ModuleSymversInfo(restore_path: str)`, and `KernelEnvInfo(setup: str)`. These pieces information can\u0027t be joined as easily as `depset()`s or `list`s; they must be merged in a case-by-case basis. Admittedly, I can deal with them one by one (in this case, they all happen to be able to transformed to `depset`s). But I\u0027ll need to do this process again for other rules if I want to use them later.\n\nI hope this use case makes sense. What\u0027s your suggestion on approaching this problem?",
      "parentUuid": "82e111fe_c33477d6",
      "range": {
        "startLine": 247,
        "startChar": 5,
        "endLine": 247,
        "endChar": 53
      },
      "revId": "52288610ea611611a7ea8bb1b3424e881483065b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec34b60b_2995aa28",
        "filename": "kleaf/impl/kernel_module.bzl",
        "patchSetId": 35
      },
      "lineNbr": 247,
      "author": {
        "id": 1066075
      },
      "writtenOn": "2022-09-20T09:32:58Z",
      "side": 1,
      "message": "\u003e \u003e\u003e\u003e WALL OF TEXT WARNING \u003c\u003c\u003c\n\u003e \n\u003e The use of `target_group` allows me to do CL:2201118 and CL:2201916. As the comment says, I want a filegroup, but for targets so that a dependent target also sees all providers of targets in the group.\n\u003e \n\u003e Take the two CLs for example. I want to have `slider_ddk_modules_install` to say:\n\u003e \n\u003e ```\n\u003e kernel_modules \u003d [\"//...:nfc\"]\n\u003e ```\n\u003e \n\u003e ... that is effectively equivalent to ...\n\u003e \n\u003e ```\n\u003e kernel_modules \u003d [\"//...:st21nfc\", \"//...:ese/st33spi\", \"//...:ese/st54spi\"]\n\u003e ```\n\u003e \n\u003e kernel_modules_install requests `KernelModuleInfo` from its `kernel_modules` attribute.\nIs desired that \":nfc\" act completely like a kernel_module? If not, a very pedestrian solution would be to turn \":nfc\" into a simple Starlark constant defined in some .bzl file like this:\n\nnfc.bzl:\n```\nNFC_MODULE_LIST\u003d\":st21nfc\", \"..:s33spi\", \"...:st54spi\"\n```\n\nthen, in a BUILD file you\u0027d say:\n\n```\nload(\":nfc.bzl\", \"NFC_MODULE_LIST\")\n\nkernel_modules \u003d NFC_MODULE_LIST + [...]\n```\n\nI\u0027m not sure if this is better. It does require more BUILD boilerplate but less Starlark code.\n\n\n\u003e \n\u003e This is just an example. I might want to put a `target_group` of `kernel_modules` in the `deps` of a `kernel_module` too, which requests `KernelEnvInfo`, `DdkHeadersInfo` as well. (KernelEnvInfo has a list[File] which needs to be converted to depset too, I know -\u003e b/247624301)\n\u003e \n\u003e \u003e You also seem to put references to ConfiguredTarget objects in providers; this, by itself, works, but it\u0027s also a little strange. The Bazelic way is to aggregate all the information you need at every node in the dependency graph.\n\u003e \n\u003e Indeed, there are many examples of doing this in Kleaf project. I\u0027ll clean this up with b/247622808.\n\u003e \n\u003e Is there any text in the Bazel documentation to discourage people from doing this?\nI don\u0027t think so; it\u0027s not *necessarily* bad, it\u0027s more like a design smell that makes it difficult to avoid O(n^2) situations.\n\n\u003e \n\u003e \u003e A quick look at DdkHeadersInfo in ddk_headers.bzl indicates that DdkHeaders.files is already the transitive headers. But then why do you need to look at your transitive DdkHeaderInfo providers?\n\u003e \n\u003e I think you are suggesting to create a rule that exports DdkHeadersInfo as the merged info. I assume you are referring to this solution:\n\u003e \n\u003e ```\n\u003e def _kernel_module_group_impl(ctx):\n\u003e   return [\n\u003e     DdkHeadersInfo(\n\u003e       files \u003d depset(transitive \u003d [target[DdkHeadersInfo].files for target in ctx.attr.srcs),\n\u003e       includes \u003d \u003csame, merge ctx.attr.srcs\u003e\n\u003e     ),\n\u003e     # Other infos\n\u003e   ]\n\u003e kernel_module_group \u003d rule(\n\u003e   impl \u003d _kernel_module_group_impl,\n\u003e   attrs \u003d {\"srcs\": attr.label_list(providers \u003d [DdkHeadersInfo, ...])},\n\u003e )\n\u003e ```\n\u003e \n\u003e ```\n\u003e kernel_module(name \u003d \"a\")\n\u003e kernel_module(name \u003d \"b\")\n\u003e \n\u003e kernel_modules_install(name \u003d \"x\", kernel_modules \u003d [\"a\", \"b\"])\n\u003e # becomes\n\u003e kernel_module_group(name \u003d \"group\", srcs \u003d [\"a\", \"b\"])\n\u003e kernel_modules_install(name \u003d \"x\", kernel_modules \u003d [\"group\"])\n\u003e ```\n\u003e \n\u003e This solution:\n\u003e \n\u003e - Is specific to kernel_module / ddk_module\u0027s. Unlike target_group, I can\u0027t use it for other rules with other infos.\n\u003e   - This means if the providers that kernel_module exports changes, kernel_module_group also need to change.\n\u003e - Does not work for other infos. See below.\n\u003e \n\u003e For example, a `kernel_module` also exports `KernelUnstrippedModulesInfo(directory: File)`, `ModuleSymversInfo(restore_path: str)`, and `KernelEnvInfo(setup: str)`. These pieces information can\u0027t be joined as easily as `depset()`s or `list`s; they must be merged in a case-by-case basis. Admittedly, I can deal with them one by one (in this case, they all happen to be able to transformed to `depset`s). But I\u0027ll need to do this process again for other rules if I want to use them later.\n\u003e \n\u003e I hope this use case makes sense. What\u0027s your suggestion on approaching this problem?\n\nYep, that\u0027s exactly the approach I was thinking about; my line of reasoning is that if you do this:\n* you are fully in control of the information that propagates up the dependency graph (kernel_module_install doesn\u0027t know anything you don\u0027t want it to)\n* Whoever looks at the code of (e.g.) kernel_module_group immediately knows what information passes through it\n* It\u0027s easier to avoid having O(n^2) time complexity (if you care; I don\u0027t know how many modules you have, if not too many, it\u0027s not necessarily a problem)\n\nthat, of course, comes at the cost of having to write you own rule class for each use case. FWIW, in google3, \"merging on a case-by-case basis\" is the law of the land, to the extent that we can enforce any laws. There, the main motivation is to avoid O(n^2) behavior.\n\nHow `KernelUnstrippedModulesInfo` and `ModuleSymversInfo` need to be merged?",
      "parentUuid": "6d6b7726_4487f78c",
      "range": {
        "startLine": 247,
        "startChar": 5,
        "endLine": 247,
        "endChar": 53
      },
      "revId": "52288610ea611611a7ea8bb1b3424e881483065b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}