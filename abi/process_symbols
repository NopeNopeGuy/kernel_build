#!/usr/bin/env python3
#
# Copyright (C) 2021 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This is an internal helper script used by build.sh and build_abi.sh
#
# arguments are:
#   abi_sl - the dist directory ABI symbol list
#   kernel_dir
#   main_symbol_list_file_name
#   (additional_symbol_list_file_name)*

import argparse
from enum import Enum
import logging
import os
import sys


class Status(Enum):
    UNKNOWN = 0
    ALLOWED = 1
    FORBIDDEN = 2


log = logging.getLogger(__name__)


_FORBIDDEN_SYMBOLS = {
    'read_file': 'file operation',
    'msleep': 'just testing'
}

_ALLOWED_SYMBOLS = {
    'module_layout',
     '__put_task_struct'
}

def _read_symbol_list(symbol_list, symbols, lines):
    """Reads a previously created libabigail symbol list."""
    with open(symbol_list) as wl:
        for l in wl:
            lines.append(l)
            stripped = l.strip()
            if not stripped or stripped.startswith('#') or stripped.startswith('['):
                continue
            symbols.add(stripped)
    # Separate files and protect against missing final newline.
    lines.append('\n')


def _check_symbols(symbols):
    report = []
    for symbol in sorted(symbols):
        if symbol in _FORBIDDEN_SYMBOLS:
            report.append([symbol, Status.FORBIDDEN, _FORBIDDEN_SYMBOLS[symbol]])
        elif symbol in _ALLOWED_SYMBOLS:
            report.append([symbol, Status.ALLOWED, ''])
        else:
            report.append([symbol, Status.UNKNOWN, ''])
    return report


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('symbol_lists', metavar='file', type=str, nargs='+',
                        help='a symbol list file')
    parser.add_argument('--in-dir', default=None, required=True,
                        help='where to find the symbol list files')
    parser.add_argument('--out-dir', default=None, required=True,
                        help='where to put the output and report files')
    parser.add_argument('--out-file', default=None, required=True,
                        help='where to write the combined symbol list')
    parser.add_argument('--report-file', default=None, required=True,
                        help='where to write the symbol list report')

    args = parser.parse_args()

    in_directory = args.in_dir
    out_directory = args.out_dir
    symbol_lists = [os.path.join(in_directory, s) for s in args.symbol_lists]
    out_file = os.path.join(out_directory, args.out_file)
    report_file = os.path.join(out_directory, args.report_file)

    symbols = set()
    lines = []
    for in_file in symbol_lists:
        _read_symbol_list(in_file, symbols, lines)

    log.info('========================================================')
    log.info('Generating ABI symbol list definition in {}'.format(out_file))
    with open(out_file, 'w') as sl:
        sl.writelines(lines)

    exit_status = 0
    log.info('Generating ABI symbol report {}'.format(report_file))
    report = _check_symbols(symbols)
    with open(report_file, 'w') as rf:
        for row in report:
            (symbol, status, reason) = row
            rf.write('{}\t{}\t{}\n'.format(symbol, status.name, reason))
            if status == Status.FORBIDDEN:
                exit_status = 1

    return exit_status

if __name__ == '__main__':
    sys.exit(main())
