#!/usr/bin/env python3
#
# Copyright (C) 2021 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This is an internal helper used by build.sh and build_abi.sh

import argparse
import enum
import logging
import os
import sys


class Status(enum.Enum):
    UNKNOWN = 0
    ALLOWED = 1
    FORBIDDEN = 2


log = logging.getLogger(__name__)


_FORBIDDEN_SYMBOLS = {
    'read_file': 'file operation',
    'msleep': 'just testing'
}

_ALLOWED_SYMBOLS = {
    'module_layout',
     '__put_task_struct'
}


def _read_symbol_lists(symbol_lists):
    """Read libabigail symbol list files a list of lines."""
    lines = []
    for symbol_list in symbol_lists:
        with open(symbol_list, 'r') as sl:
            for line in sl:
                lines.append(line)
        # Separate files or at least protect against missing final newlines.
        lines.append('\n')
    return lines


def _get_symbols(lines):
    """Get symbols from symbol list lines."""
    symbols = set()
    for line in lines:
        stripped = line.strip()
        if stripped and not stripped.startswith(('#', '[')):
            symbols.add(stripped)
    return symbols


def _check_symbols(symbols):
    report = []
    for symbol in sorted(symbols):
        if symbol in _FORBIDDEN_SYMBOLS:
            report.append([symbol, Status.FORBIDDEN, _FORBIDDEN_SYMBOLS[symbol]])
        elif symbol in _ALLOWED_SYMBOLS:
            report.append([symbol, Status.ALLOWED, ''])
        else:
            report.append([symbol, Status.UNKNOWN, ''])
    return report


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('symbol_lists', metavar='FILE', type=str, nargs='+',
                        help='a symbol list file')
    parser.add_argument('--in-dir', required=True,
                        help='where to find the symbol list files')
    parser.add_argument('--out-dir', required=True,
                        help='where to put the combined symbol list and report')
    parser.add_argument('--out-file', required=True,
                        help='combined symbol list file name')
    parser.add_argument('--report-file', required=True,
                        help='symbol list report file name')

    args = parser.parse_args()

    in_directory = args.in_dir
    out_directory = args.out_dir
    symbol_lists = [os.path.join(in_directory, s) for s in args.symbol_lists]
    out_file = os.path.join(out_directory, args.out_file)
    report_file = os.path.join(out_directory, args.report_file)

    lines = _read_symbol_lists(symbol_lists)
    symbols = _get_symbols(lines)
    report = _check_symbols(symbols)

    log.info('========================================================')
    log.info(f'Generating ABI symbol list definition in {out_file}')
    with open(out_file, 'w') as sl:
        sl.writelines(lines)

    exit_status = 0
    log.info(f'Generating ABI symbol report {report_file}')
    with open(report_file, 'w') as rf:
        for symbol, status, reason in report:
            rf.write(f'{symbol}\t{status.name}\t{reason}\n')
            if status == Status.FORBIDDEN:
                log.error(f'symbol \'{symbol}\' is not allowed: {reason}')
                exit_status = 1

    return exit_status

if __name__ == '__main__':
    sys.exit(main())
