#!/usr/bin/env python3
#
# Copyright (C) 2023 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Enforce build time GKI modules symbol protection.

Implements a mechanism to ensure that all undefined symbols in unsigned modules
are either listed as part of the Kernel Module Interface (KMI) or defined by
another unsigned module at build time. Failure to meet this requirement will
prevent the module from loading at runtime, even if the build is successful.
This is because the symbol is likely exported by a signed (GKI) module and is
protected from being accessed by unsigned (vendor) modules, providing an early
warning at the build time to avoid a testing iteration.

Usage:

   check_buildtime_symbol_protection --abi-symbol-list ABI_SYMBOL_LIST
   [directory]
"""
import argparse
import os
import subprocess
import sys

import symbol_extraction


def main():
  """Enforces all undefined symbols in unsiged modules are defined in other unsigned modules or symbollist"""

  parser = argparse.ArgumentParser()
  parser.add_argument(
      "directory",
      nargs="?",
      default=os.getcwd(),
      help="the directory to search for unsigned modules")

  parser.add_argument(
      "--abi-symbol-list",
      required=True,
      help="ABI symbol list with symbols which are allow listed to access by unsigned modules"
  )

  parser.add_argument(
      "--print-unsigned-modules",
      action="store_true",
      help="Emit the names of the processed unsigned modules")

  args = parser.parse_args()

  if not os.path.isdir(args.directory):
    print("Expected a directory to search for unsigned modules, but got %s" %
          args.directory)
    return 1

  modules = []
  for root, dirs, files in os.walk(args.directory):
    for file in files:
      if file.endswith(".ko"):
        modules.append(os.path.join(root, file))

  # Find unsigned modules
  unsigned_modules = list(
      filter(lambda module: not symbol_extraction.is_signature_present(module),
             modules))

  # Find all undefined symbols from unsigned modules
  undefined_symbols = [
      module for sublist in map(symbol_extraction.extract_undefined_symbols,
                                unsigned_modules) for module in sublist
  ]

  # Find all defined symbols from unsigned modules
  defined_symbols = [
      module for sublist in map(symbol_extraction.extract_exported_symbols,
                                unsigned_modules) for module in sublist
  ]

  # Read ABI symbols in a list
  abi_symbols = symbol_extraction.read_symbol_list(args.abi_symbol_list)

  # Using set difference to get elements in undefined but not in defined or symbollist
  missing_symbols = list(
      set(undefined_symbols) - set(defined_symbols) - set(abi_symbols))

  if missing_symbols:
    print(
        "\nThese symbols are missing from symbol list and not available at runtime for unsigned modules:"
    )
    print("  " + "\n  ".join(symbol for symbol in missing_symbols))
    return 1

  if args.print_unsigned_modules:
    print(
        "These modules have been checked for GKI protected symbol violations:")
    print("  " + "\n  ".join(
        sorted([os.path.basename(mod) for mod in unsigned_modules])))

  return 0


if __name__ == "__main__":
  sys.exit(main())
